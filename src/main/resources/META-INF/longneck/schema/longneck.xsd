<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
           xmlns:tns="urn:hu.sztaki.ilab.longneck:1.0"
           targetNamespace="urn:hu.sztaki.ilab.longneck:1.0"
           xmlns:d="urn:hu.sztaki.ilab.longneck.doc:1.0" 
           elementFormDefault="qualified"
           >
  <!-- xmlns="http://www.w3.org/1999/xhtml" -->
  <!-- $Id$ -->
  
  <!-- XML Schema for longneck -->

  <!-- Version: 1.0-SNAPSHOT -->

  <!-- Abstract Source -->
  <xs:complexType name="sourceContainerType">
    <xs:annotation>
      <xs:documentation>
        Sequence of <code>tns:abstract-source</code>.
      </xs:documentation>
    </xs:annotation>   
    <xs:sequence>
      <xs:element ref="tns:abstract-source" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:element name="source" type="tns:sourceContainerType" />

  <xs:complexType name="sourceType" />
  <xs:element name="abstract-source" type="tns:sourceType" abstract="true" />

  <!-- identifier type for field names and variables -->
  <xs:simpleType name="identifierType"> 
    <xs:annotation>
      <xs:documentation>
        Identifier, an alphanumeric string optionally beginning with '$', may contain '_', '-' or '.'.
        Examples: abc, $def, $_my_val, foo.bar
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <!-- Java: 
           <xs:pattern value="(\$)?[0-9a-zA-Z_.]+"/> 
      -->
      <!-- libxml2: 
           <xs:pattern value="$?[0-9a-zA-Z_.]+"/> 
      -->

      <xs:pattern value="(\$)?[0-9a-zA-Z_.-]+"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- identifier list -->
  <xs:simpleType name="identifierListType">
    <xs:annotation>
      <xs:documentation>
        List of identifiers.
      </xs:documentation>
    </xs:annotation>                    
    <xs:list itemType="tns:identifierType"/>
  </xs:simpleType>

  <!-- field name -->
  <xs:simpleType name="fieldNameType">
    <xs:annotation>
      <xs:documentation>
        Identifier, an alphanumeric string optionally beginning with '$', may contain '_', '-' or '.'.
        Examples: abc, $def, $_my_val, foo.bar
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="(\$)?[0-9a-zA-Z_.-]+"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- field name list type -->
  <xs:simpleType name="fieldNameListType">
    <xs:annotation>
      <xs:documentation>
        List of field names.
      </xs:documentation>
    </xs:annotation>    
    <xs:list itemType="tns:fieldNameType"/>
  </xs:simpleType>

  <!-- generic block, constraint and entity id type -->
  <xs:simpleType name="genericIdType">
    <xs:annotation>
      <xs:documentation>
        Name of the block by which it can be referred to.
      </xs:documentation>
    </xs:annotation>    
    <xs:restriction base="xs:string">
      <xs:pattern value="[0-9a-zA-Z_.-]+"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- referred block, constraint and entity id type -->
  <xs:simpleType name="referenceIdType">
    <xs:annotation>
      <xs:documentation>
        Identifier of the package, followed by ':' and the name of the referred block.
      </xs:documentation>
    </xs:annotation>    
    <xs:restriction base="xs:string">
      <xs:pattern value="[0-9a-zA-Z_.-]+:[0-9a-zA-Z_.-]+"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- generic version type -->
  <xs:simpleType name="genericVersionType">
    <xs:annotation>
      <xs:documentation>
        The version of the block, to distinguish variants of the same transformation.
      </xs:documentation>
    </xs:annotation>    
    <xs:restriction base="xs:string">
      <xs:pattern value="[0-9a-zA-Z.\-]+"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Repository item reference attribute group -->
  <xs:attributeGroup name="referenceAttrGroup">
    <xs:attribute name="id" type="tns:referenceIdType" use="required"/>
    <xs:attribute name="version" type="tns:genericVersionType" use="optional"/>
  </xs:attributeGroup>

  <!-- Referred repository item attribute group -->
  <xs:attributeGroup name="referredAttrGroup">
    <xs:attribute name="id" type="tns:genericIdType" use="required"/>
    <xs:attribute name="version" type="tns:genericVersionType"/>
  </xs:attributeGroup>

  <!-- abstract block -->
  <xs:complexType name="abstractBlockType"/>
  <xs:element name="abstract-block" type="tns:abstractBlockType" abstract="true"/>
  

  <!-- block element group -->
  <xs:group name="blockElementGroup">
    <xs:sequence>
      <xs:element ref="tns:abstract-block" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:group>

  <!-- atomic block attribute group -->
  <xs:attributeGroup name="atomicBlockAttrGroup">
    <xs:attribute name="apply-to" type="tns:identifierListType" use="required">
      <xs:annotation>
        <xs:documentation>
          List of fields this element applies to.
        </xs:documentation>
      </xs:annotation>                    
    </xs:attribute>
  </xs:attributeGroup>

  <!-- atomic block type -->
  <xs:complexType name="atomicBlockType">
    <xs:annotation>
      <xs:documentation>
        Abstract atomic block type.
      </xs:documentation>
    </xs:annotation>        
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:attributeGroup ref="tns:atomicBlockAttrGroup"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- atomic field only block type -->
  <xs:complexType name="atomicFieldOnlyBlockType">
    <xs:annotation>
      <xs:documentation>
        Abstract field-only block type.
      </xs:documentation>
    </xs:annotation>        
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:attribute name="apply-to" type="tns:fieldNameListType" use="required">
          <xs:annotation>
            <xs:documentation>
              List of fields this element applies to.
            </xs:documentation>
          </xs:annotation>              
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- regexp block type -->
  <xs:complexType name="regexpBlockType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="regexp" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              A regular expression.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- sequence type -->
  <xs:complexType name="sequenceType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:group ref="tns:blockElementGroup" minOccurs="0" maxOccurs="unbounded"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- BLOCK ELEMENTS -->

  <!-- Add flag -->
  <xs:complexType name="abstractFlagBlockType">
    <xs:annotation>
      <xs:documentation>
        Abstract flag-related type.
      </xs:documentation>
    </xs:annotation>    
    <xs:complexContent>
      <xs:extension base="tns:atomicFieldOnlyBlockType">
        <xs:attribute name="flag" type="tns:constraintFlagType" use="required">
          <xs:annotation>
            <xs:documentation>
              Defines the flag type for the operation.
            </xs:documentation>
          </xs:annotation>              
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="add-flag" type="tns:abstractFlagBlockType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Adds a pre-defined flag to the fields listed in the apply-to attribute. The flag can
        be chosen from the values specified below.
      </xs:documentation>
      <xs:documentation d:example="true">
        <add-flag apply-to="field1 field2" flag="INVALID"/>
      </xs:documentation>
    </xs:annotation>      
  </xs:element>

  <!-- Block reference -->
  <xs:complexType name="blockReferenceType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:sequence>
          <xs:element ref="tns:abstract-mapping-rule" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attributeGroup ref="tns:referenceAttrGroup"/>
        <xs:attribute name="propagate-failure" type="xs:boolean">
          <xs:annotation>
            <xs:documentation>
              Enables error propagation from the referred block to the outer environment. Errors
                originating from the referred block must be handled at the block reference level.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="block-ref" type="tns:blockReferenceType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Calls a block from an external package. You may use a mapping from the field names of the
          record to the names used inside the block, but when you do, you must list all used names,
          or a warning is issued each time an unmapped field name is accessed. If an error occurs
          inside the called block, the execution of the block is halted and processing continues
          from the block reference, unless you set the <code>propagate-failure</code> attribute.
      </xs:documentation>
      <xs:documentation d:example="true">
        <block-ref id="email:e-mail.multiple.process.skipnull"/>
      </xs:documentation>
      <xs:documentation>
        This is a simple block reference without mapping.
      </xs:documentation>
      <xs:documentation d:example="true">
         <block-ref id="name:name.canonize" version="1.0" >
           <unprefix fields="rep_tempname rep_temp_remain " text="rep_"/>
           <prefix fields="tempname temp_remain " text="rep_"/>
           <postfix fields="tempname temp_remain " text="_rep"/>
           <pass fields="tempname temp_remain"/>
           <map from="work-raw-extension" to="raw-extension"/>
         </block-ref>
      </xs:documentation>
      <xs:documentation>
        A block reference with field name mapping and version attribute.
      </xs:documentation>
      <xs:documentation d:example="true">
        <block-ref id="email:e-mail.multiple.process.skipnull" propagate-failure="true"/>
      </xs:documentation>
      <xs:documentation>
        Block reference with error propagation enabled.
      </xs:documentation>
    </xs:annotation>  
  </xs:element>

  <!-- Break -->
  <xs:complexType name="breakType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType"/>        
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="break" type="tns:breakType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Halts the execution of the current block, and returns to the step after the calling block 
          reference. This does not trigger an error event.
      </xs:documentation>
      <xs:documentation d:example="true">
        <break/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Fail -->
  <xs:complexType name="failType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType"/>        
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="fail" type="tns:failType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Halts the processing of the currently transformed record with failure. The record is not
          written to the output and an error event is recorded.
      </xs:documentation>
      <xs:documentation d:example="true">
        <fail/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Filter -->
  <xs:complexType name="filterType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType"/>        
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="filter" type="tns:filterType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Halts the processing of the currently transformed record. This does not trigger an error
          event.
      </xs:documentation>
      <xs:documentation d:example="true">
        <filter/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>
  
  <!-- Case -->
  <xs:complexType name="caseType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:sequence>
          <xs:group ref="tns:blockElementGroup" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="case" type="tns:caseType" substitutionGroup="tns:abstract-block">   
    <xs:annotation>
      <xs:documentation>
        A single case in a switch-like structure.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Check -->
  <xs:complexType name="checkType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:group ref="tns:constraintElementGroup" minOccurs="1" maxOccurs="unbounded"/>
        <xs:attribute name="summary" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              A short summary of the implemented checks that goes into the error report, very useful for
                debugging a failed constraint check.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="checkedfield" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The field that is checked. The field's value is included in the error report for debugging.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="check" type="tns:checkType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        This block performs the checks defined in it, and triggers an error event when the check fails.
      </xs:documentation>
      <xs:documentation d:example="true">
        <check summary="Checks, if bm-code is exactly four digits plus one letter."  checkedfield="bm-code">
          <match apply-to="bm-code" regexp="^\d{4}[A-Z0]?$"/>
        </check>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Clear flags -->
  <xs:complexType name="clearFlagsType">
    <xs:complexContent>
      <xs:extension base="tns:atomicFieldOnlyBlockType">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="clear-flags" type="tns:clearFlagsType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Clears all flags from the fields specified in the apply-to attribute.
      </xs:documentation>
      <xs:documentation d:example="true">
        <clear-flags apply-to="field1 field2"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Collapse whitespace -->
  <xs:complexType name="collapseWhitespaceType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="collapse-whitespace" type="tns:collapseWhitespaceType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Collapses sequences of whitespace characters to single space characters.
        This block does not remove additional whitespace from the beginning and the end of a string.
        Also see trim.
      </xs:documentation>
      <xs:documentation d:example="true">
        <collapse-whitespace apply-to="county"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Copy -->
  <xs:complexType name="copyType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="from" type="tns:identifierType">
          <xs:annotation>
            <xs:documentation>
              The name of the field to copy from.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="with-flags" type="xs:boolean">
          <xs:annotation>
            <xs:documentation>
              If tha value is true also copy source flags if any.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="copy" type="tns:copyType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Copies the value of the specified field in the from attribute to other fields.        
      </xs:documentation>
      <xs:documentation d:example="true">
        <copy apply-to="public-domain-type" from="$1"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Cut -->
  <xs:complexType name="cutType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="value" type="xs:integer" use="required">
          <xs:annotation>
            <xs:documentation>
              The maximum length of the field value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="cut" type="tns:cutType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Cuts the length of the specified field values to a maximum size.
      </xs:documentation>
      <xs:documentation d:example="true">
        <cut apply-to="a b c" value="4"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- DateTime To Format -->
  <xs:complexType name="dateTimeToFormatType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="from" type="tns:identifierType">
          <xs:annotation>
            <xs:documentation>
              The field, which contains the input date that is transformed.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="from-pattern" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The pattern of the input date.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="to-pattern" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The output pattern of the date being converted.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="datetime-to-format" type="tns:dateTimeToFormatType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Converts a date and time string to the given format. This operation does not support time 
          zones in the output.
      </xs:documentation>
      <xs:documentation d:example="true">
        <datetime-to-format apply-to="timeInMillis" from="time" fromPattern="dd/MMM/yyyy:HH:mm:ss Z" toPattern=""/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>
  
  <!-- DateTime To Milliseconds -->
  <xs:complexType name="dateTimeToMillisecondsType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="from" type="tns:identifierType">
          <xs:annotation>
            <xs:documentation>
              The input date.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="pattern" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The pattern of the input date.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="datetime-to-milliseconds" type="tns:dateTimeToMillisecondsType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Converts a date and time to milliseconds from the Epoch (1970-01-01 00:00:00.000).
      </xs:documentation>
      <xs:documentation d:example="true">
        <datetime-to-milliseconds apply-to="timeInMillis" from="time" pattern="dd/MMM/yyyy:HH:mm:ss Z"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Generic block -->
  <xs:complexType name="genericBlockType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:sequence>
          <xs:element name="input-constraints" type="tns:checkType" minOccurs="0" maxOccurs="1">
            <xs:annotation>
              <xs:documentation>
                Constraints on the record before the execution of this block.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="tns:blockElementGroup" minOccurs="0" maxOccurs="unbounded"/>
          <xs:element name="output-constraints" type="tns:checkType" minOccurs="0" maxOccurs="1">
            <xs:annotation>
              <xs:documentation>
                Constraints on the record after the block has been executed.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attributeGroup ref="tns:referredAttrGroup"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="block" type="tns:genericBlockType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        The generic block is a callable subsequence of transformation steps, which can be referred
          by it's id and optional version. These blocks are stored in block packages, which are 
          available from the repository.
      </xs:documentation>
      <xs:documentation d:example="true">
        <block id="address.canonize.init-place-name-hu.skipnull" version="1.0">
          <if>
            <is-null apply-to="place-name" />
            <then>
              <break/>
            </then>
          </if>
          <trim apply-to="place-name"/>
          <collapse-whitespace apply-to="place-name"/>
          <set-character-case apply-to="place-name" case="Lowercase" characters="ALL" />
          <!--    <set-character-case apply-to="place-name" case="Uppercase" characters="TOKEN_INITIALS" />-->
          <set-character-case apply-to="place-name" case="Uppercase" characters="TOKEN_INITIALS_NON_ALNUM" />
          <replace-all apply-to="place-name" regexp=".*((?i)N/A).*" replacement="" />
          <replace-all apply-to="place-name" regexp="^Bpest" replacement="Budapest" />
          <replace-all apply-to="place-name" regexp="^(Bp\.?)" replacement="Budapest" />
          <replace-all apply-to="place-name" regexp="^(Pest)" replacement="Budapest" />
          <replace-all apply-to="place-name" regexp="^(Buda)[\P{L}]" replacement="Budapest" />
          <replace-all apply-to="place-name" regexp="^Ismeretlen Irányítószám !$" replacement="" />
          <trim apply-to="place-name"/>
          <collapse-whitespace apply-to="place-name"/>
        </block>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- If -->
  <xs:complexType name="ifType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:sequence>
          
          <!-- conditions -->
          <xs:group ref="tns:constraintElementGroup" minOccurs="1" maxOccurs="unbounded"/>

          <!-- then -->
          <xs:element name="then" type="tns:sequenceType"/>

          <!-- else -->
          <xs:element name="else" type="tns:sequenceType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>	
  </xs:complexType>

  <xs:element name="if" type="tns:ifType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        If-then-else control structure.
      </xs:documentation>
      <xs:documentation d:example="true">
        <if>
          <equals apply-to="$has-type" value="false"/>
          <not-null apply-to="public-domain-type" />
          <then>
            <if>
              <entity-ref id="address:address.part.public-domain-type.hu" version="1.0" />
              <then>
                <replace-all apply-to="public-domain-name" regexp="\s(\S*)$" replacement=""/>
                <trim apply-to="public-domain-name"/>
              </then>
              <else>
                <set-null apply-to="public-domain-type"/>
              </else>
            </if>
          </then>
        </if>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Implode -->
  <xs:complexType name="implodeType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="glue" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              The separator character put between the joined values, may be empty string.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="sources" type="tns:identifierListType" use="required">
          <xs:annotation>
            <xs:documentation>
              The name of fields to joins.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="skip-empty-strings" type="xs:boolean">
          <xs:annotation>
            <xs:documentation>
              Enables skipping of empty string values or nulls from result.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="implode" type="tns:implodeType" substitutionGroup="tns:abstract-block" >
    <xs:annotation>
      <xs:documentation>
        Joins the values of the fields listed in source and adds the text defined in the glue parameter in between them.
      </xs:documentation>
      <xs:documentation d:example="true">
        <implode apply-to="house-number" sources="F_HAZSZAM F_AJTO" glue="."  skip-empty-strings="true"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Add-prefix, add-postfix -->
  <xs:complexType name="abstractAddFixBlockType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="text" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              The text to add to the names.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="add-prefix" type="tns:abstractAddFixBlockType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Adds a mapping from the original field names to the prefixed names.
      </xs:documentation>
      <xs:documentation d:example="true">
        <add-prefix apply-to="house-number" text="home_" />
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:element name="add-postfix" type="tns:abstractAddFixBlockType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Adds a mapping from the original field names to the postfixed names.
      </xs:documentation>
      <xs:documentation d:example="true">
        <add-postfix apply-to="house-number" text="_home" />
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- MatchExtract -->
  <xs:complexType name="matchExtractType">
    <xs:complexContent>
      <xs:extension base="tns:regexpBlockType">
        <xs:sequence>
          <xs:group ref="tns:blockElementGroup" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="match-extract" type="tns:matchExtractType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Matches the input against regular expression and extracts regexp groups.
        The groups defined in the regular expression are exported as variables starting from $0, which
        contains the entire match.
        Note, that the MatchExtract block behaves like a check block. If the specified regular
        expression does not match the input, an error event is triggered.
      </xs:documentation>
      <xs:documentation d:example="true">
        <match-extract apply-to="phone-number" regexp="^(\d)(\d+)$">
          <if>
            <equals apply-to="$1" with="country-code"/>
            <then>
              <copy apply-to="phone-number" from="$2" />
            </then>
          </if>
        </match-extract>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>
  
  <!-- Milliseconds To DateTime -->
  <xs:complexType name="millisecondsToDateTimeType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="from" type="tns:identifierType" use="required">
          <xs:annotation>
            <xs:documentation>
              The name of the field which contains the number of milliseconds.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="pattern" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              The pattern of the output date.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="milliseconds-to-datetime" type="tns:millisecondsToDateTimeType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Converts milliseconds to formatted date and time string.
      </xs:documentation>
      <xs:documentation d:example="true">
        <milliseconds-to-datetime apply-to="date" from="timeinMillisecounds" pattern="dd/MMM/yyyy:HH:mm:ss Z"/>
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Remove -->
  <xs:element name="remove" type="tns:atomicBlockType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Removes a field from the record. Note: Variables cannot be removed. A variable is deleted when 
          execution leaves the scope where it was defined.
      </xs:documentation>
      <xs:documentation d:example="true">
        <remove apply-to="date"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Remove flag -->
  <xs:element name="remove-flag" type="tns:abstractFlagBlockType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Remove a given flag from all of the fields listed in the apply-to attribute.
      </xs:documentation>
      <xs:documentation d:example="true">
        <remove-flag apply-to="field1 field2" flag="INVALID"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Remove prefix -->
  <xs:complexType name="removePrefixType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="from" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              The field to read from.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="prefix" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              The prefix to remove.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="remove-prefix" type="tns:removePrefixType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        If the field value starts with the specified text, this block removes that prefix.
      </xs:documentation>
      <xs:documentation d:example="true">
        <remove-prefix apply-to="house_number" text="home_" />
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Replace All -->
  <xs:complexType name="replaceType">
    <xs:complexContent>
      <xs:extension base="tns:regexpBlockType">
        <xs:attribute name="replacement" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              Replacement string.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="replace-all" type="tns:replaceType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Replaces all occurences of the match attribute with the value of the replacement attribute.
      </xs:documentation>
      <xs:documentation d:example="true">
        <replace-all apply-to="unit" regexp="(=\/|^)0(?=\/|$)" replacement="" />
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Replace First -->
  <xs:element name="replace-first" type="tns:replaceType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Replaces the first occurence of the match attribute with the value of the replacement attribute.
      </xs:documentation>
      <xs:documentation d:example="true">
        <replace-first apply-to="unit" regexp="(=\/|^)0(?=\/|$)" replacement="" />
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Set -->
  <xs:complexType name="setType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="value" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              The new value of the field.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType> 
  
  <xs:element name="set" type="tns:setType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>  
        Sets the field or variable to the specified constant value.
      </xs:documentation>
      <xs:documentation d:example="true">
        <set apply-to="$unit" value="em"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Set Character Case -->
  <xs:simpleType name="characterTargetType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ALL"/>
      <xs:enumeration value="FIRST"/>
      <xs:enumeration value="TOKEN_INITIALS"/>
      <xs:enumeration value="TOKEN_INITIALS_NON_ALNUM"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="setCharacterCaseType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="characters" type="tns:characterTargetType" use="required">
          <xs:annotation>
            <xs:documentation>
              The characters to change.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="case" type="tns:characterCaseType" use="required">
          <xs:annotation>
            <xs:documentation>
              The character case to apply.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="set-character-case" type="tns:setCharacterCaseType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Changes the case of the selected characters to the specified case.
      </xs:documentation>
      <xs:documentation d:example="true">
        <set-character-case apply-to="country" case="Lowercase" characters="ALL" />
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Set Null -->
  <xs:complexType name="setNullType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType"/>        
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="set-null" type="tns:setNullType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Set the value of the given fields or variables to null.
      </xs:documentation>
      <xs:documentation d:example="true">
        <set-null apply-to="zip-code" />
      </xs:documentation>
    </xs:annotation> 
  </xs:element>
  

  <!-- Switch -->
  <xs:complexType name="switchType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:sequence>
          <xs:element ref="tns:case" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="switch" type="tns:switchType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Switch-like control structure. Executes each case, which meets the condition for that case 
          in sequential order, until the  first case succeeds. Changes made to the record in failed 
          cases are rolled back, and have no effect on the data.
      </xs:documentation>
      <xs:documentation d:example="true">
        <switch>
          <!-- Hungarian mobile nr -->
          <case>
            <block-ref id="phonenr:phone-number.extract-hun-mobile" version="1.0" propagate-failure="true"/>
          </case>
          <!-- Hungarian country nr -->
          <case>
            <block-ref id="phonenr:phone-number.extract-hun-rural" version="1.0" propagate-failure="true"/>
          </case>
          <!-- Hungarian nr : Budapest 1 -->
          <case>
            <block-ref id="phonenr:phone-number.extract-hun-budapest" version="1.0" propagate-failure="true"/>
          </case>
          <!-- Set as empty - removed as error/invalid handling completed -->
          <case>
            <block-ref id="phonenr:phone-number.set-null" version="1.0" propagate-failure="true"/>
          </case>
        </switch>
        <block-ref id="email:e-mail.multiple.process.skipnull" version="1.0"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Switch Strict -->
  <xs:element name="switch-strict" type="tns:switchType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Strict switch control structure.
        It provides the same functionality as switch class, but triggers an error event if all
          cases fail.
      </xs:documentation>
      <xs:documentation d:example="true">
        <switch-strict>
          <!-- Hungarian mobile nr -->
          <case>
            <block-ref id="phonenr:phone-number.extract-hun-mobile" version="1.0" propagate-failure="true"/>
          </case>
          <!-- Hungarian country nr -->
          <case>
            <block-ref id="phonenr:phone-number.extract-hun-rural" version="1.0" propagate-failure="true"/>
          </case>
          <!-- Hungarian nr : Budapest 1 -->
          <case>
            <block-ref id="phonenr:phone-number.extract-hun-budapest" version="1.0" propagate-failure="true"/>
          </case>
          <!-- Set as empty - removed as error/invalid handling completed -->
          <case>
            <block-ref id="phonenr:phone-number.set-null" version="1.0" propagate-failure="true"/>
          </case>
        </switch-strict>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Trim -->
  <xs:complexType name="trimType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="trim" type="tns:trimType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Removes whitespace from the beginning and the end of the values of specified fields.
      </xs:documentation>
      <xs:documentation d:example="true">
        <trim apply-to="unit"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Try All -->
  <xs:element name="try-all" type="tns:switchType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Try all cases control structure.
        This control behaves much like a switch structure, but it tries all cases,
        regardless of which succeeds or not. Unsuccessful block executions are rolled back, and have
        no effect on the record.
      </xs:documentation>
      <xs:documentation d:example="true">
        <try-all>
          <case>
            <check summary="test summary">
              <not-null apply-to="f1 f2 $v1 $v2"/>	  
            </check>
            <copy apply-to="if1 if2 $if3 $if4" from="if5"/>	
          </case>
          <case>
            <check summary="test summary">
              <not-null apply-to="f3 f4 $v1 $v2"/>	  
            </check>
            <copy apply-to="if1 i_f2 $if.3 $if4" from="if5"/>	
          </case>
        </try-all>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- Unicode normalize -->
  <xs:complexType name="unicodeNormalizeType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:attribute name="form">
          <xs:annotation>
            <xs:documentation>
              The form of normalization, see http://unicode.org/reports/tr15/#Norm_Forms
            </xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="NFD"/>
              <xs:enumeration value="NFC"/>
              <xs:enumeration value="NFKD"/>
              <xs:enumeration value="NFKC"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="unicode-normalize" type="tns:unicodeNormalizeType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Normalizes a value according the normalization type.
      </xs:documentation>
      <xs:documentation d:example="true">
        <unicode-normalize apply-to="$a b c" form="NFD"/>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>

  <!-- ExtractTimestamp -->
  <xs:complexType name="extractTimestampType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:sequence>
          <xs:group ref="tns:blockElementGroup" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="extract-timestamp" type="tns:extractTimestampType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Converts the specified timestamp into a date, and assigns date fields to the variables $year, 
          $month, $day, $hour, $min, and $sec.
      </xs:documentation>
      <xs:documentation d:example="true">
        <extract-timestamp apply-to="timestamp">
			<copy apply-to="year" from="$year" />
			<copy apply-to="month" from="$month" />
			<copy apply-to="day" from="$day" />
			<copy apply-to="hour" from="$hour" />
			<copy apply-to="min" from="$min" />
			<copy apply-to="sec" from="$sec" />
		</extract-timestamp>
      </xs:documentation>
    </xs:annotation> 
  </xs:element>
  
  <!-- Clone Record -->
 
  <!-- clone record attribute group -->
  <xs:attributeGroup name="cloneRecordBlockAttrGroup">
    <xs:attribute name="set-field" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The field added when record is cloned.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="set-value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The value of the newly added field.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  
  <xs:complexType name="cloneRecordType">
    <xs:complexContent>
      <xs:extension base="tns:abstractBlockType">
        <xs:attributeGroup ref="tns:cloneRecordBlockAttrGroup"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="clone-record" type="tns:cloneRecordType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
      <xs:documentation>
        Creates a new record identical to the current one and optionally adds another field to the 
          clone. The clone's transformation starts from the position of this block.
      </xs:documentation>
      <xs:documentation d:example="true">
        <clone-record set-field="ctrl_doEventSplit" set-value="true" />
      </xs:documentation>
    </xs:annotation> 
  </xs:element>
  
  <!-- CONSTRAINTS -->

  <!-- abstract constraint -->
  <xs:complexType name="abstractConstraintType"/>
  <xs:element name="abstract-constraint" type="tns:abstractConstraintType" abstract="true"/>


  <!-- Atomic constraint attribute group -->
  <xs:attributeGroup name="atomicConstraintAttrGroup">
    <xs:attribute name="apply-to" type="tns:identifierListType" use="required">
      <xs:annotation>
        <xs:documentation>
          List of fields this element is applied on.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <!-- Simple atomic constraint -->
  <xs:complexType name="atomicConstraintType">
    <xs:complexContent>
      <xs:extension base="tns:abstractConstraintType">
        <xs:attributeGroup ref="tns:atomicConstraintAttrGroup"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Constraint element group strict -->
  <xs:group name="constraintElementGroup">
    <xs:sequence>
      <xs:element ref="tns:abstract-constraint" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:group>

  <!-- Constraint element group -->
  <xs:group name="constraintElementGroupfree">
    <xs:sequence>
      <xs:element ref="tns:abstract-constraint" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:group>
  
  <!-- Character class -->
  <xs:simpleType name="characterClassType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Letter"/>
      <xs:enumeration value="Number"/>
      <xs:enumeration value="Space"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Character class list -->
  <xs:simpleType name="characterClassListType">
    <xs:list itemType="tns:characterClassType"/>
  </xs:simpleType>

  <!-- Policy -->
  <xs:simpleType name="policyType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Allow"/>
      <xs:enumeration value="Deny"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Alphabet constraint -->
  <xs:complexType name="alphabetType">
    <xs:complexContent>
      <xs:extension base="tns:atomicConstraintType">
        <xs:attribute name="classes" type="tns:characterClassListType" use="required">
          <xs:annotation>
            <xs:documentation>
              Character classes checked in this constraint.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="policy" type="tns:policyType" use="optional" default="Allow">
          <xs:annotation>
            <xs:documentation>
              Allow or deny policy for character containment.
            </xs:documentation>
          </xs:annotation>                                                                                 
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="alphabet" type="tns:alphabetType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks if characters in the input value come from the specified alphabet. The policy 
            defines if the characters in the alphabet are allowed or denied.
        </xs:documentation>
        <xs:documentation d:example="true">
          <alphabet apply-to="a b c" classes="Letter Number" policy="Deny"/>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Is Longer constraint -->
  <xs:complexType name="isnotlongerType">
    <xs:complexContent>
      <xs:extension base="tns:atomicConstraintType">
        <xs:attribute name="value" type="xs:integer" use="required">
          <xs:annotation>
            <xs:documentation>
              The maximum acceptable length of the value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="is-notlonger" type="tns:isnotlongerType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks if the input value is not longer than a given length.
        </xs:documentation>
        <xs:documentation d:example="true">
          <is-notlonger apply-to="a b c" value="4"/>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- And operator -->
  <xs:complexType name="andTypefree">
    <xs:complexContent>
      <xs:extension base="tns:abstractConstraintType">
        <xs:sequence>
          <xs:group ref="tns:constraintElementGroupfree" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <!-- And operator -->
  <xs:complexType name="andType">
    <xs:complexContent>
      <xs:extension base="tns:abstractConstraintType">
        <xs:sequence>
          <xs:group ref="tns:constraintElementGroup" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="and" type="tns:andType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Defines a logical AND relationship between the contained constraints.
        </xs:documentation>
        <xs:documentation d:example="true">
          <and>
            <not-null apply-to="zip-code" />
            <exists apply-to="zip-code" />
          </and>
        </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Character case -->
  <xs:simpleType name="characterCaseType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Uppercase"/>
      <xs:enumeration value="Lowercase"/>
      <xs:enumeration value="Capitalized"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Constraint flag -->
  <xs:simpleType name="constraintFlagType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="INVALID"/>
      <xs:enumeration value="NOT_APPLICABLE"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Constraint reference -->
  <xs:complexType name="constraintReferenceType">
    <xs:complexContent>
      <xs:extension base="tns:abstractConstraintType">
        <xs:sequence>
          <xs:element ref="tns:abstract-mapping-rule" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attributeGroup ref="tns:referenceAttrGroup"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="constraint-ref" type="tns:constraintReferenceType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Reference to a constraint in an external package.
        </xs:documentation>
        <xs:documentation d:example="true">
        <constraint-ref id="package4:some.constraint" version="3.0">
          <pass fields="a b c"/>
          <prefix fields="d e" text="fff"/>
          <postfix fields="g h" text="iii"/>
          <map from="j" to="k"/>          
          <map from="j" to="k"/>          
          <map from="j" to="k"/>          
          <map from="j" to="k"/>          
        </constraint-ref>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Entity reference -->
  <xs:element name="entity-ref" type="tns:constraintReferenceType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Reference to an entity in an external package.
        </xs:documentation>
        <xs:documentation d:example="true">
          <entity-ref id="address:address.part.zip-code.hu" version="1.0" >
            <pass fields="a b c"/>
            <prefix fields="d e" text="fff"/>
            <postfix fields="g h" text="iii"/>
            <map from="j" to="k"/>          
            <map from="j" to="k"/>          
            <map from="j" to="k"/>          
            <map from="j" to="k"/> 
          </entity-ref>
        </xs:documentation>
    </xs:annotation>
  </xs:element>
  
  <!-- Equals constraint -->
  <xs:complexType name="equalsType">
    <xs:complexContent>
      <xs:extension base="tns:atomicConstraintType">
        <xs:attribute name="value" type="xs:string" use="optional">
          <xs:annotation>
            <xs:documentation>
              Value to be equal with.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="with" type="tns:identifierType" use="optional">
          <xs:annotation>
            <xs:documentation>
              The identifier of the field the checked fields must be equal to.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="equals" type="tns:equalsType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks, if the specified field's value equals the value in the given field in the 
            <code>with</code> attribute. The values are compared as strings.
        </xs:documentation>
        <xs:documentation d:example="true">
          <equals apply-to="house-number" with="hrsz" />
        </xs:documentation>
        <xs:documentation>
          Checks, if the apply-to fields value equals to the specified constant.
        </xs:documentation>
        <xs:documentation d:example="true">
          <equals apply-to="house-number" value="113" />
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Equals imploded constraint -->
  <xs:complexType name="equalsImplodedType">
    <xs:complexContent>
      <xs:extension base="tns:atomicConstraintType">
        <xs:attribute name="sources" type="tns:identifierListType" use="required">
          <xs:annotation>
            <xs:documentation>
              The list of sources.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="glue" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              The glue to merge between parts.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="equals-imploded" type="tns:equalsImplodedType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Implode the source fields using glue. Checks if the apply-to field values equal the created fieled.
        </xs:documentation>
        <xs:documentation d:example="true">
          <equals-implode apply-to="house-number" sources="F_HAZSZAM F_AJTO" glue="." />
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Exists constraint -->
  <xs:element name="exists" type="tns:atomicConstraintType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks, if the specified field exists according to the fields list.
        </xs:documentation>
        <xs:documentation d:example="true">
          <exists apply-to="zip-code" />
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- False constraint -->
  <xs:element name="false" type="tns:atomicConstraintType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks if the field is false. 
          The field value is lowercased, and checked against the string "false".
        </xs:documentation>
        <xs:documentation d:example="true">
          <false apply-to="field1"/>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Generic constraint -->
  <xs:complexType name="genericConstraintType">
    <xs:complexContent>
      <xs:extension base="tns:andTypefree">
        <xs:attributeGroup ref="tns:referredAttrGroup"/>	
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="constraint" type="tns:genericConstraintType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Constraint with id and version.
        </xs:documentation>
        <xs:documentation d:example="true">
          <constraint id="address.part.public-domain-type.hu" version="1.0">
            <lookup apply-to="public-domain-type">
              <external-wordset column-name="word">
                <wordset-file-source
                  source-file="longneck-jobs/lookup_resources/wordsets/cr_address/domain_type.txt" />
              </external-wordset>
            </lookup>
          </constraint>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Generic entity -->
  <xs:element name="entity" type="tns:genericConstraintType">
    <xs:annotation>
        <xs:documentation>
          Entity implementation.
        </xs:documentation>
        <xs:documentation d:example="true">
          <entity id="address.part.public-domain-type.hu" version="1.0">
            <lookup apply-to="public-domain-type">
              <external-wordset column-name="word">
                <wordset-file-source
                  source-file="longneck-jobs/lookup_resources/wordsets/cr_address/domain_type.txt" />
              </external-wordset>
            </lookup>
          </entity>
        </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- Has flag constraint -->
  <xs:complexType name="hasFlagType">
    <xs:complexContent>
      <xs:extension base="tns:atomicConstraintType">
        <xs:attribute name="flag" type="tns:constraintFlagType" use="required">
          <xs:annotation>
            <xs:documentation>
              Defines the flag type for the operation.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="has-flag" type="tns:hasFlagType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks, if the field has the specified flag.
        </xs:documentation>
        <xs:documentation d:example="true">
          <has-flag apply-to="flag1" flag="INVALID"/>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Is null constraint -->
  <xs:element name="is-null" type="tns:atomicConstraintType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks, if the specified field is null.
        </xs:documentation>
        <xs:documentation d:example="true">
          <is-null apply-to="country" />
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Is empty constraint -->
  <xs:element name="is-empty" type="tns:atomicConstraintType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks, if the specified field is empty.
        </xs:documentation>
        <xs:documentation d:example="true">
          <is-empty apply-to="house-number" />
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Match constraint -->
  <xs:complexType name="matchType">
    <xs:complexContent>
      <xs:extension base="tns:andTypefree">
        <xs:attributeGroup ref="tns:atomicConstraintAttrGroup"/>
        <xs:attribute name="regexp" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              A regular expression.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="match" type="tns:matchType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks, if the field matches the specified regular expression.
          Matched subgroups can also be checked using contained constraints. The match groups are assigned
          to variables $0, $1, $2... and so on, within the match constraint scope.
        </xs:documentation>
        <xs:documentation d:example="true">
          <match apply-to="unit" regexp="(?i:hrsz?(:|.)?)"/>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Not null constraint -->
  <xs:element name="not-null" type="tns:atomicConstraintType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks, if the specified field is not null.
        </xs:documentation>
        <xs:documentation d:example="true">
          <not-null apply-to="bm-code" />
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Not empty constraint -->
  <xs:element name="not-empty" type="tns:atomicConstraintType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks, if the specified field is not empty.
        </xs:documentation>
        <xs:documentation d:example="true">
          <not-empty apply-to="bm-code" />
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Not operator -->
  <xs:complexType name="notOperatorType">
    <xs:complexContent>
      <xs:extension base="tns:abstractConstraintType">
        <xs:sequence>
          <xs:group ref="tns:constraintElementGroup"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:element name="not" type="tns:notOperatorType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Negates the result of the contained constraint check.
        </xs:documentation>
        <xs:documentation d:example="true">
          <not>
            <exists apply-to="unit" />
          </not>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- Or operator -->
  <xs:element name="or" type="tns:andType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Or operator for constraints.
        </xs:documentation>
        <xs:documentation d:example="true">
          <or>
            <is-empty apply-to="house-number" />
            <when>
              <not-null apply-to="house-number" />
              <then>
                <not>
                  <entity-ref id="address:address.part.house-number.hu" version="1.0" />
                </not>
              </then>
            </when>
            <equals apply-to="house-number" with="hrsz" />
            <match apply-to="unit" regexp="(?i:hrsz?(:|.)?)"/>
          </or>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- True constraint -->
  <xs:element name="true" type="tns:atomicConstraintType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Checks, if the specified field is true.
          This check is performed on a string value, ie. the field has to equal "true" in it's
          lowercased form.
        </xs:documentation>
        <xs:documentation d:example="true">
          <true apply-to="field1"/>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- When -->
  <xs:complexType name="whenType">
    <xs:complexContent>
      <xs:extension base="tns:andType">
        <xs:sequence>
          <xs:element name="then" type="tns:andType">
            <xs:annotation>
              <xs:documentation>
                Then branch with additional checks.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="else" type="tns:andType" minOccurs="0" maxOccurs="1">
            <xs:annotation>
              <xs:documentation>
                Else branch with additional checks.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="when" type="tns:whenType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          If-then-else control structure to constraint.
        </xs:documentation>
        <xs:documentation d:example="true">
          <when>
              <not-null apply-to="house-number" />
              <then>
                <not>
                  <entity-ref id="address:address.part.house-number.hu" version="1.0" />
                </not>
              </then>
            </when>
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- OrCase -->
  <xs:complexType name="orcaseType">
    <xs:complexContent>
      <xs:extension base="tns:andTypefree">
        <xs:sequence>
          <xs:element name="then" type="tns:andType">
            <xs:annotation>
              <xs:documentation>
                Then branch with additional checks.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="orcase" type="tns:orcaseType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          OrCase in an or-switch structure.
        </xs:documentation>
      </xs:annotation>
  </xs:element>

  <!-- OrSwitch -->
  <xs:complexType name="orswitchStrictType">
    <xs:complexContent>
      <xs:extension base="tns:abstractConstraintType">
        <xs:sequence>
          <xs:element ref="tns:orcase" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- OrSwitch Strict -->
  <xs:element name="orswitch-strict" type="tns:orswitchStrictType" substitutionGroup="tns:abstract-constraint">
    <xs:annotation>
        <xs:documentation>
          Strict or-switch control structure.       
          This structure check trough all straight orcase constraint, if some constraint is true, then the
          or-switch constraint result equals the orcasre then result.
        </xs:documentation>
        <xs:documentation d:example="true">
          <orswitch-strict>
            <orcase>
              <entity-ref id="phonenr:phone-number.canonized.hu.selector" version="1.0"/>
              <then>
                <entity-ref id="phonenr:phone-number.canonized.hu" version="1.0"/>
              </then>
            </orcase>
            <orcase>
              <entity-ref id="phonenr:phone-number.canonized.sk.selector" version="1.0"/>
              <then>
                <entity-ref id="phonenr:phone-number.canonized.sk" version="1.0"/>
              </then>
            </orcase>
          </orswitch-strict>
        </xs:documentation>
    </xs:annotation>
  </xs:element>

  <!-- MAPPING -->

  <!-- Mapping rule type -->
  <xs:complexType name="abstractMappingRuleType"/>
  <xs:element name="abstract-mapping-rule" type="tns:abstractMappingRuleType" abstract="true"/>

  <!-- Pass -->
  <xs:complexType name="passType">
    <xs:complexContent>
      <xs:extension base="tns:abstractMappingRuleType">
        <xs:attribute name="fields" type="tns:fieldNameListType" use="required"/>        
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="pass" type="tns:passType" substitutionGroup="tns:abstract-mapping-rule"/>

  <!-- Prefix -->
  <xs:complexType name="abstractFixType">
    <xs:complexContent>
      <xs:extension base="tns:passType">
        <xs:attribute name="text" type="tns:fieldNameType" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="prefix" type="tns:abstractFixType" substitutionGroup="tns:abstract-mapping-rule"/>

  <!-- Unprefix -->
  <xs:element name="unprefix" type="tns:abstractFixType" substitutionGroup="tns:abstract-mapping-rule"/>

  <!-- Postfix -->
  <xs:element name="postfix" type="tns:abstractFixType" substitutionGroup="tns:abstract-mapping-rule"/>

  <!-- Map -->
  <xs:complexType name="mapType">
    <xs:complexContent>
      <xs:extension base="tns:abstractMappingRuleType">
        <xs:attribute name="from" type="tns:fieldNameType" use="required"/>
        <xs:attribute name="to" type="tns:fieldNameType" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="map" type="tns:mapType" substitutionGroup="tns:abstract-mapping-rule"/>

  <!-- Caching -->
  <xs:attributeGroup name="cachingAttrGroup">
    <xs:attribute name="output-fields" type="tns:identifierListType" use="required">
      <xs:annotation>
        <xs:documentation>
          Value of the cache.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size" type="xs:integer" > 
      <xs:annotation>
        <xs:documentation>
          Maximum size.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  
  <xs:complexType name="cachingType">
    <xs:complexContent>
      <xs:extension base="tns:atomicBlockType">
        <xs:sequence>
          <xs:group ref="tns:blockElementGroup" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attributeGroup ref="tns:cachingAttrGroup"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="caching" type="tns:cachingType" substitutionGroup="tns:abstract-block">
    <xs:annotation>
        <xs:documentation>
          Block that caches block outputs as key-value pairs it contains.
          Each thread has its own internal cache (LRUMap). Cache key is the field 
          value defined in the "apply-to" parameter. Note that only one field name 
          is permitted here! Cache value is a list of fields defined in the 
          "output-fields" parameter.
        </xs:documentation>
        <xs:documentation d:example="true">
          <caching apply-to="userAgent" size="100"
                   output-fields="userAgentAgentName 
                     userAgentAgentType 
                     userAgentAgentVersion 
                     userAgentLang
                     userAgentOS 
                     userAgentOSVersion 
                     userAgentOSDistro 
                     userAgentLayoutEngine 
                     userAgentLayoutRes 
                     userAgentDevice 
                     userAgentProcessor 
                     userAgentSWPlatform">
            <copy apply-to="userAgentAgentName" from="userAgent" />
          </caching>
        </xs:documentation>
      </xs:annotation>
  </xs:element>
  
</xs:schema>
